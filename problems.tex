\documentclass[a4paper,12pt]{article}



\usepackage[export]{adjustbox}
\usepackage[russian]{babel}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}



\usepackage{amsbsy}
\usepackage{amscd}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amsopn}
\usepackage{amssymb}
\usepackage{amstext}
\usepackage{amsthm}
\usepackage{amsxtra}
\usepackage{array}
\usepackage{ctable}
\usepackage{geometry}
\usepackage{hyperref}
\usepackage{latexsym}
\usepackage{listings}
\usepackage{makecell}
\usepackage{ragged2e}
\usepackage{titlesec}
\usepackage{tocloft}
\usepackage{xcolor}



\renewcommand{\familydefault}{\sfdefault}

\renewcommand{\arraystretch}{1.5}

\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}

\geometry{left   = 0.5cm}
\geometry{bottom = 0.5cm}
\geometry{right  = 0.5cm}
\geometry{top    = 0.5cm}

\parindent = 0pt
\parskip   = 0pt
\tolerance = 100

\flushbottom

\definecolor{G}{rgb}{0.00, 0.50, 0.00}

\hypersetup
{
    linkcolor  = G,
    urlcolor   = G,
    colorlinks = true
}

\renewenvironment{itemize}
{
    \begin{list}{\labelitemi}
    {
      \setlength{\topsep}{0pt}
      \setlength{\partopsep}{0pt}
      \setlength{\parskip}{0pt}
      \setlength{\itemsep}{0pt}
      \setlength{\parsep}{0pt}
      \setlength{\leftmargin}{14.5pt}
    }
}{\end{list}}

\definecolor{B}{rgb}{0.00, 0.00, 0.50}

\lstset
{
    backgroundcolor   = \color{white},      % Установка цвета заднего плана  
    basicstyle        = \ttfamily\color{B}, % Установка размера и цвета шрифта
    breakatwhitespace = true,               % Установка разрывов на пробелах
    breaklines        = true,               % Установка переноса длинных строк
    captionpos        = none,               % Установка позиции имени листинга
    commentstyle      = \color{B},          % Установка цвета комментариев кода
    deletekeywords    = {},                 % Установка удаленных ключевых слов  
    escapeinside      = {\%*}{*)},          % Установка добавления LaTeX в коде  
    extendedchars     = false,              % Установка дополнительных символов 
    frame             = L,                  % Установка типа рамки вокруг кода
    framexleftmargin  = -8pt,               % Установка размера левого отступа
    keepspaces        = true,               % Установка выравнивания пробелов
    keywordstyle      = \color{B},          % Установка цвета ключевых слов  
    language          = C++,                % Установка языка программирования
    otherkeywords     = {},                 % Установка добавочных ключевых слов   
    numbers           = none,               % Установка позиции нумерации строк
    numbersep         = 0pt,                % Установка отступа нумерации строк
    numberstyle       = \color{black},      % Установка цвета нумерации строк
    showspaces        = false,              % Установка пробелов символом '_'
    showstringspaces  = false,              % Установка пробелов символом '_'
    showtabs          = false,              % Установка табуляторов видимыми
    stepnumber        = 1,                  % Установка периода нумерации строк
    stringstyle       = \color{B},          % Установка цвета строковых литералов
    tabsize           = 2,                  % Установка размера табуляции в коде
}



\begin{document}



\newpage\thispagestyle{empty}\pdfpageheight = 2.50in\enlargethispage{100in}

\title{\bf Software Engineering} 

\author{Moscow Institute of Physics and Technology}

\date{}

\maketitle



\newpage\thispagestyle{empty}\pdfpageheight = 6.10in\enlargethispage{100in}

\renewcommand\contentsname{\Large Table of Contents}

\renewcommand{\cftdotsep}{0.5}

\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}}

\makeatletter
\let\latexl@section\l@section
\def\l@section#1#2{\begingroup\let\numberline\@gobble\latexl@section{#1}{#2}\endgroup}
\makeatother

\titlelabel{}

\thispagestyle{empty}\tableofcontents\thispagestyle{empty}



\newpage\thispagestyle{empty}\pdfpageheight = 4.20in

\textbf{\Large 00. Mandatory Requirements}

\bigskip

\,\textbf{Требования: часть 1}

\medskip

\begin{itemize}

    \item Ваши решения должны собираться без предупреждений с флагами\;-Wall,\;-Wextra\;и\;-Wpedantic.

    \smallskip

    \item Ваши решения должны сопровождаться тестами\:и\:демонстрационными\:примерами.

    \smallskip

    \item Ваши решения должны выполняться\;до\;конца\;и\;проходить\;тесты\;без\;ошибок\;и\;неопределенного\;поведения.

    \smallskip

    \item Ваши решения должны располагаться\;каждое\;в\;отдельном\;единственном\;файле\;исходного\;кода.

    \smallskip

    \item Ваши решения должны быть адекватно отформатированы в рамках единого стиля.
    
\end{itemize}

\bigskip

\,\textbf{Требования: часть 2}

\medskip

\begin{itemize}

    \item Ваши решения не должны содержать символы,\;не\;представленные\;в\;таблице\;семибитного\:стандарта\:ASCII.

    \smallskip

    \item Ваши решения не должны содержать магические\;литералы и непонятные\;названия.

    \smallskip

    \item Ваши решения не должны содержать неинициализированные\,переменные\,и\,глобальные\,объекты.

    \smallskip

    \item Ваши решения не должны содержать дублирующийся код и неиспользуемые части.

    \smallskip

    \item Ваши решения не должны содержать избыточного использования стандартных\,потоков\,для\,ввода\,и\,вывода.

\end{itemize}

\bigskip

\,В случае конфликтов требований в приоритете является выполнение требований, указанных в условиях задач.



\newpage\thispagestyle{empty}\pdfpageheight = 5.20in

\section{01. Introduction and Brief Overview}

{\large \textbf{01.01} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/06.07.cpp}{\texttt{06.07}}]}} 

\bigskip

Напишите программу, которая выводит в стандартный символьный поток вывода \lstinline{std::cout} любую строку и при этом обладает функцией \lstinline{main} с единственной инструкцией \lstinline{return 0}. Предложите по крайней мере четыре разных решения. Впервые я столкнулся с этой задачей на техническом собеседовании в крупную российскую компанию. Для ее решения Вам потребуются технологии, которые будут рассматриваться во втором, третьем и шестом модулях данного курса, поэтому Вы можете пропустить эту задачу и вернуться к ней позже. Возможно, Вы немного удивились тому, что первая же задача данного курса обладает настолько неадекватным уровнем сложности. Это своеобразная дань памяти моему детству. Я начал серьезно изучать компьютерные науки и языки программирования в 12 лет, когда проводил летние школьные каникулы на даче у бабушки с дедушкой. Родители подарили мне две книги: Программирование -- принципы и практика с использованием C\texttt{++} Бьёрна Страуструпа и Язык программирования C Брайана Кернигана и Денниса Ритчи. Также у меня имелся простой ноутбук со средой разработки Code::Blocks, однако не было ни интернета, ни даже мобильной связи, потому что дача находится в низине, а сеть можно поймать только на определенном тайном холмике в лесу. Я решил начать изучение с визуально небольшой книги по языку C, быстро проработать ее, а потом приступить к монографии Страуструпа. Опрометчивое решение! В одном из первых заданий просили написать программу, которая удалила бы все комментарии из исходного кода другой программы на языке C. Предположу, что это весьма сложная задача для третьего дня изучения программирования, но я справился, потому что из-за отсутствия связи с внешним миром я просто не понял, что это сложно. Возможно, именно этот случай помог мне определиться с основным направлением всей дальнейшей деятельности. Любопытно, что случилось, если бы мне тогда подарили монографию Искусство программирования Дональда Кнута? Возможно, я стал бы лучше относиться к математике. Пожалуй, стоит провести небольшой эксперимент над собственными детьми.



\newpage\thispagestyle{empty}\pdfpageheight = 17.50in\enlargethispage{100in}

\section{02. Basics of Programming}

{\large \textbf{02.01} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/02.12.cpp}{\texttt{02.12}}]}}

\bigskip

Реализуйте алгоритм вычисления N\,-\,ого числа ряда Фибоначчи на основе формулы Бине. Используйте тип \lstinline{double} для промежуточных вычислений и тип \lstinline{int} для конечного значения числа ряда Фибоначчи. Используйте оператор \lstinline{static_cast} для преобразования округленного приближенного значения формулы Бине типа \lstinline{double} к конечному значению типа \lstinline{int}. Используйте константы для значений в формуле Бине. Используйте стандартные функции \lstinline{std::sqrt}, \lstinline{std::pow} и \lstinline{std::round}. Обоснуйте формулу Бине. Используйте стандарт- ный символьный поток ввода \lstinline{std::cin} для ввода номера N. Используйте стандартный символьный поток вы- 

вода \lstinline{std::cout} для вывода числа ряда Фибоначчи. Не сопровождайте Ваше решение данной задачи тестами.

\bigskip

{\large \textbf{02.02} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/02.17.cpp}{\texttt{02.17}}]}}

\bigskip

Реализуйте алгоритм вычисления корней алгебраического уравнения второй степени с коэффициентами a, b и c типа \lstinline{double}. Используйте ветвления \lstinline{if} для проверки значения коэффициента a и значения дискриминанта. Используйте константу epsilon и стандартную функцию \lstinline{std::abs} для корректного сравнения чисел типа \lstinline{double} с заданной точностью. Допускайте появление отрицательного нуля. Используйте стандартный символьный поток ввода \lstinline{std::cin} для ввода коэффициентов a, b и c. Используйте стандартный\,символьный\,по- 

ток вывода \lstinline{std::cout} для вывода корней уравнения. Не сопровождайте Ваше решение данной задачи тестами.

\bigskip

{\large \textbf{02.03} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/02.18.cpp}{\texttt{02.18}}]}}

\bigskip

Реализуйте алгоритм классификации символов типа \lstinline{char} из таблицы ASCII с десятичными кодами от 32 до 127 включительно на пять следующих классов: заглавные буквы, строчные буквы, десятичные цифры, знаки препинания, прочие символы. Используйте ветвление \lstinline{switch} с проваливанием и символьными литералами типа \lstinline{char} в качестве меток в секциях \lstinline{case}. Протестируйте нестандартное расширение компилятора g\texttt{++} для диапазонов и флаг компилятора -Wpedantic. Используйте секцию \lstinline{default} для пятого класса. Используйте стандартный символьный поток ввода \lstinline{std::cin} для\,ввода\,символов.\,Используйте\,стандартный\,символьный\,по- 

ток вывода \lstinline{std::cout} для вывода названий классов. Не сопровождайте Ваше решение данной задачи тестами.

\bigskip

{\large \textbf{02.04} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/02.20.cpp}{\texttt{02.20}}]}}

\bigskip

Реализуйте алгоритм вычисления всех трехзначных чисел Армстронга. Используйте тройной вложенный цикл \lstinline{for} для перебора. Не используйте стандартную функцию \lstinline{std::pow}. Используйте стандартный символьный поток вывода \lstinline{std::cout} для вывода чисел Армстронга. Не\:сопровождайте\:Ваше\:решение\:данной\:задачи\:тестами.

\bigskip

{\large \textbf{02.05} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/02.24.cpp}{\texttt{02.24}}]}}

\bigskip

Реализуйте алгоритм вычисления числа e на основе суммы членов ряда Маклорена при x равном 1 с точностью, заданной числом epsilon. Используйте тип \lstinline{double} для промежуточных вычислений и конечного значения числа e. Не вычисляйте факториалы в знаменателях членов ряда Маклорена, чтобы не столкнуться с проблемой переполнения. Используйте известное соотношение между членами ряда Маклорена для оптимизации вычисления каждого нового члена ряда на основе предыдущего члена ряда. Используйте цикл \lstinline{while} для вычисления членов ряда Маклорена, пока очередной член ряда не станет меньше числа epsilon. Используйте стандартный символьный поток ввода \lstinline{std::cin} для ввода числа epsilon. Используйте стандартный символьный поток вывода \lstinline{std::cout} для вывода числа e. Не сопровождайте Ваше решение данной задачи тестами.

\bigskip

{\large \textbf{02.06} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/02.29.cpp}{\texttt{02.29}}]}}

\bigskip

Реализуйте алгоритмы вычисления максимального и минимального значений, медианы, среднего арифметического и стандартного отклонения коллекции чисел типа \lstinline{double}. Используйте встроенный статический массив для хранения и обработки коллекции чисел. Используйте стандартный символьный поток ввода \lstinline{std::cin} для ввода коллекции чисел. Используйте любой удобный для Вас способ ввода коллекции чисел, например, с предварительным вводом размера коллекции чисел. Реализуйте алгоритм сортировки пузырьком как подготовительную часть алгоритма вычисления медианы коллекции чисел. Используйте стандартный символьный поток вывода \lstinline{std::cout} для вывода максимального и минимального значений, медианы, среднего арифмети- 

ческого и стандартного отклонения коллекции чисел. Не сопровождайте Ваше решение данной задачи тестами.

\bigskip

{\large \textbf{02.07} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/02.30.cpp}{\texttt{02.30}}]}}

\bigskip

Доработайте Ваше предыдущее решение задачи 02.06 таким образом, чтобы вместо встроенного статического массива использовался встроенный динамический массив. Предполагайте, что размер коллекции чисел заранее неизвестен. Реализуйте алгоритм увеличения емкости встроенного динамического массива в процессе его использования. Реализуйте выделение нового блока памяти размером в два раза больше предыдущего, копирование всех данных из предыдущего блока памяти в новый и освобождение предыдущего блока памяти.

\bigskip

{\large \textbf{02.08} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/02.31.cpp}{\texttt{02.31}}]}}

\bigskip

Реализуйте алгоритм вычисления наибольшей длины последовательности Коллатца среди всех последовательностей, начинающихся со значений от 1 до 100. Используйте тип \lstinline{unsigned long long int} для значений последовательностей Коллатца и тип \lstinline{std::size_t} для длин последовательностей. Используйте кэширование длин последовательностей Коллатца в стандартном контейнере \lstinline{std::vector} для оптимизации вычисления длины каждой новой последовательности на основе предыдущих последовательностей. Используйте стандартный символьный поток вывода \lstinline{std::cout} для вывода наибольшей длины последовательности Коллатца среди всех рассмотренных, а также ее начального значения. Не сопровождайте Ваше решение данной задачи тестами.

\bigskip

{\large \textbf{02.09} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/02.43.cpp}{\texttt{02.43}}]}}

\bigskip

Реализуйте алгоритмы вычисления наибольшего общего делителя двух натуральных чисел типа \lstinline{int} на основе рекурсивного и итративного подходов, а также алгоритм вычисления наименьшего общего кратного двух натуральных чисел типа \lstinline{int}. Используйте стандартные функции \lstinline{std::gcd} и \lstinline{std::lcm} для валидации результатов.

\bigskip

{\large \textbf{02.10} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/02.44.cpp}{\texttt{02.44}}]}}

\bigskip

Доработайте пример \href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/02.44.cpp}{\texttt{02.44}} таким образом, чтобы вместо алгоритма сортировки слиянием использовался алгоритм быстрой сортировки. Реализуйте метод Хоара. Используйте медиану первого, среднего и последнего элементов как опорный элемент. Обоснуйте временную сложность полученного\;гибридного\;алгоритма\;сортировки.



\newpage\thispagestyle{empty}\pdfpageheight = 21.90in\enlargethispage{100in}

\section{03. Object\,-\,Oriented Programming}

{\large \textbf{03.01} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/03.02.cpp}{\texttt{03.02}}]}}

\bigskip

Реализуйте структуру \lstinline{Rectangle} для представления прямоугольников со сторонами, которые параллельны осям координатной плоскости. Реализуйте в структуре \lstinline{Rectangle} четыре поля типа \lstinline{int} для хранения координат левого верхнего и правого нижнего углов прямоугольника. Используйте систему координат, в которой ось абсцисс направлена вправо, а ось ординат направлена вниз. Реализуйте алгоритм вычисления площади пересечения нескольких прямоугольников. Рассмотрите случаи пустого и вырожденного пересечения прямоуголь- 

ников. Реализуйте алгоритм вычисления наименьшего ограничивающего несколько прямоугольников прямоу-

гольника. Используйте стандартный контейнер \lstinline{std::vector} для хранения экземпляров структуры \lstinline{Rectangle}.

\bigskip

{\large \textbf{03.02} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/03.04.cpp}{\texttt{03.04}}]}}

\bigskip

Реализуйте класс \lstinline{Triangle} для представления треугольников. Реализуйте в классе \lstinline{Triangle} три приватных поля типа \lstinline{double} для хранения длин трех сторон. Реализуйте класс \lstinline{Square} для представления квадратов. Реализуйте в классе \lstinline{Square} одно приватное поле типа \lstinline{double} для хранения длины одной стороны. Реализуйте класс \lstinline{Circle} для представления окружностей. Реализуйте в классе \lstinline{Circle} одно приватное поле типа \lstinline{double} для хранения радиуса. Реализуйте в классах \lstinline{Triangle}, \lstinline{Square} и \lstinline{Circle} пользовательские конструкторы и публичные функции-члены \lstinline{perimeter} и \lstinline{area} для вычисления периметра и площади соответственно. Используйте стандартную константу \lstinline{std::numbers::pi} в функциях-членах \lstinline{perimeter} и \lstinline{area} класса \lstinline{Circle}.

\bigskip

{\large \textbf{03.03} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/03.05.cpp}{\texttt{03.05}}]}}

\bigskip

Реализуйте класс \lstinline{List} для представления односвязного списка. Реализуйте структуру \lstinline{Node} для представления узлов односвязного списка как приватную вложенную структуру в классе \lstinline{List}. Реализуйте в структуре \lstinline{Node} одно поле типа \lstinline{int} для хранения значения текущего узла списка и одно поле типа \lstinline{Node *} для хранения адреса следующего узла списка. Реализуйте в классе \lstinline{List} два приватных поля типа \lstinline{Node *} для хранения адресов первого и последнего узлов списка. Не создавайте в классе \lstinline{List} поля для хранения текущего размера списка и пользовательские конструкторы. Реализуйте в классе \lstinline{List} публичную функцию-член \lstinline{empty} для проверки наличия хотя бы одного узла в списке. Реализуйте в классе \lstinline{List} публичную функцию-член \lstinline{show} для вывода в стандартный символьный поток вывода \lstinline{std::cout} значений всех текущих узлов списка. Реализуйте в классе \lstinline{List} публичные функции-члены \lstinline{push_front} и \lstinline{push_back} для вставки новых узлов с пользовательскими значениями в начало и в конец списка соответственно. Используйте оператор \lstinline{new} для динамического выделения памяти. Реализуйте в классе \lstinline{List} публичные функции-члены \lstinline{pop_front} и \lstinline{pop_back} для удаления узлов из начала и из конца списка соответственно. Используйте оператор \lstinline{delete} для освобождения памяти. Реализуйте в классе \lstinline{List} публичную функцию-член \lstinline{get} для получения значения текущего среднего узла списка. Используйте только один цикл для обхода списка в функции-члене \lstinline{get}~класса~\lstinline{List}.~Реализуйте~в~классе~\lstinline{List} 

пользовательский деструктор, который корректно освободит память, выделенную при создании узлов списка. 

Выполните модульное и интеграционное тестирование для всех реализованных функций-членов класса \lstinline{List}.

\bigskip

{\large \textbf{03.04} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/03.09.cpp}{\texttt{03.09}}]}}

\bigskip

Реализуйте систему внешнего тестирования приватных функций-членов некоторого класса. Реализуйте класс \lstinline{Entity}. Реализуйте в классе \lstinline{Entity} приватные функции-члены \lstinline{test_v1} и \lstinline{test_v2}, которые необходимо протестировать. Вспомните о первом принципе SOLID - принципе единственности ответственности. Реализуйте 

дружественные для класса \lstinline{Entity} дополнительные классы \lstinline{Tester_v1} и \lstinline{Tester_v2} для тестирования функций-членов \lstinline{test_v1} и \lstinline{test_v2} класса \lstinline{Entity} соответственно, чтобы получить прямой доступ к приватной секции класса \lstinline{Entity} и устранить использование публичного интерфейса класса \lstinline{Entity}. Используйте паттерн Attorney\,-\,Client для ограничения доступа классов \lstinline{Tester_v1} и \lstinline{Tester_v2} к приватной секции класса \lstinline{Entity}.

\bigskip

{\large \textbf{03.05} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/03.16.cpp}{\texttt{03.16}}]}}

\bigskip

Реализуйте систему раздельного переопределения наследуемых виртуальных функций-членов с одинаковыми сигнатурами. Реализуйте базовые классы \lstinline{Entity_v1} и \lstinline{Entity_v2}. Реализуйте в классах \lstinline{Entity_v1} и \lstinline{Entity_v2} виртуальные функции-члены \lstinline{test}, которые решают разные задачи, но имеют одинаковые сигнатуры. Реализуйте производный класс \lstinline{Client}, который является наследником интерфейсов классов \lstinline{Entity_v1} и \lstinline{Entity_v2}. Обратите внимание, что раздельное переопределение наследуемых виртуальных функций-членов \lstinline{test} в классе \lstinline{Client} невозможно из-за совпадения сигнатур. Реализуйте дополнительные классы \lstinline{Adapter_v1} и \lstinline{Adapter_v2} в иерархии наследования между классами \lstinline{Entity_v1} и \lstinline{Client} и между классами \lstinline{Entity_v2} и \lstinline{Client} соответственно. Реализуйте виртуальные функции-члены \lstinline{test_v1} и \lstinline{test_v2} в классах \lstinline{Adapter_v1} и \lstinline{Adapter_v2} соответственно, которые будут выступать в роли посредников с разными сигнатурами и позво- 

лят выполнить раздельное переопределение наследуемых виртуальных функций-членов~\lstinline{test}~в~классе~\lstinline{Client}.

\bigskip

{\large \textbf{03.06} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/03.17.cpp}{\texttt{03.17}}]}}

\bigskip

Доработайте Ваше предыдущее решение задачи 03.02 таким образом, чтобы все реализованные классы являлись наследниками одного базового класса. Реализуйте абстрактный базовый класс \lstinline{Shape} для представления интерфейса геометрических фигур. Реализуйте в классе \lstinline{Shape} виртуальный деструктор и две публичные чисто виртуальные функции-члены \lstinline{perimeter} и \lstinline{area} для вычисления периметра и площади соответственно. Реализуйте производные классы \lstinline{Triangle}, \lstinline{Square} и \lstinline{Circle}, которые являются наследниками интерфейса класса \lstinline{Shape}. Используйте спецификатор \lstinline{override} при переопределении наследуемых виртуальных функций-членов \lstinline{perimeter} и \lstinline{area} в классах \lstinline{Triangle}, \lstinline{Square} и \lstinline{Circle}. Используйте спецификатор \lstinline{final} для запрета наследования от классов \lstinline{Square} и \lstinline{Circle} и для запрета переопределения наследуемых виртуальных функций-членов \lstinline{perimeter} и \lstinline{area} в возможных наследниках класса \lstinline{Triangle}. Используйте стандартный контейнер \lstinline{std::vector} для хранения экземпляров классов \lstinline{Triangle}, \lstinline{Square} и \lstinline{Circle} через указатели на класс \lstinline{Shape}.

\bigskip

{\large \textbf{03.07} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/03.30.cpp}{\texttt{03.30}}]}}

\bigskip

Доработайте пример \href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/03.30.cpp}{\texttt{03.30}} таким образом, чтобы вектор мог увеличивать емкость встроенного динамического массива при добавлении новых элементов. Реализуйте в классе \lstinline{Vector} два приватных поля типа \lstinline{std::size_t} для хранения значений емкости и размера вектора. Реализуйте в классе \lstinline{Vector} публичные функции-члены \lstinline{capacity} и \lstinline{size} для получения значений емкости и размера вектора соответственно. Реализуйте в классе \lstinline{Vector} публичную функцию-член \lstinline{push_back} для добавления нового элемента в первую свободную ячейку памяти вектора с возможностью увеличения емкости встроенного динамического массива в случае нехватки свободных ячеек памяти. Используйте алгоритм увеличения емкости встроенного динамического массива из Вашего предыдущего решения задачи 02.07. Реализуйте в классе \lstinline{Vector} публичную функцию-член \lstinline{clear} для удаления всех элементов вектора без выполнения освобождения выделенных для них ячеек памяти. Реализуй- те в классе \lstinline{Vector} публичную функцию-член \lstinline{empty} для проверки наличия хотя бы одного элемента в векторе.

\bigskip

{\large \textbf{03.08} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/03.31.cpp}{\texttt{03.31}}]}}

\bigskip

|

\bigskip

{\large \textbf{03.09} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/03.32.cpp}{\texttt{03.32}}]}}

\bigskip

Реализуйте класс \lstinline{IPv4} для представления IP адресов стандарта IPv4. Реализуйте в классе \lstinline{IPv4} приватный встроенный статический массив из четырех элементов типа \lstinline{std::uint8_t} для хранения четырех компонент IP адресов. Реализуйте в классе \lstinline{IPv4} перегруженные операторы префиксного и постфиксного инкремента и декремента IP адресов. Реализуйте дружественные для класса \lstinline{IPv4} перегруженные операторы сравнения, ввода и вывода IP адресов. Используйте стандартный символьный поток ввода \lstinline{std::cin} для ввода IP адресов в формате четырех целых чисел от 0 до 255 включительно, разделенных точками. Используйте стандартный символьный поток вывода \lstinline{std::cout} для вывода IP адресов в\:том\:формате,\:который\:использовался\:для\:ввода.

\bigskip

{\large \textbf{03.10} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/03.34.cpp}{\texttt{03.34}}]}}

\bigskip

Доработайте пример \href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/03.32.cpp}{\texttt{03.32}} таким образом, чтобы сравнение дробей выполнялось посредством перегруженного оператора трехстороннего сравнения, переписывания выражений и перегруженного оператора сравнения на равенство вместо шести перегруженных операторов сравнения. Реализуйте дружественные для класса \lstinline{Rational} перегруженные операторы трехстороннего сравнения и сравнения на равенство. Используйте сильный порядок.



\newpage\thispagestyle{empty}\pdfpageheight = 14.50in\enlargethispage{100in}

\section{04. Generic Programming}

{\large \textbf{04.01} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/04.01.cpp}{\texttt{04.01}}]}}

\bigskip

Доработайте Ваше предыдущее решение задачи 02.10 таким образом, чтобы реализованный гибридный алгоритм сортировки мог использоваться для сортировки данных любых типов, для которых определены необходимые операции. Используйте шаблоны функций. Не изменяйте реализацию гибридного алгоритма сортировки.

\bigskip

{\large \textbf{04.02} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/04.06.cpp}{\texttt{04.06}}]}}

\bigskip

Реализуйте алгоритмы вычисления максимального и минимального значений, суммы и среднего арифметичес- 

кого всех аргументов типа \lstinline{double} из пакета. Используйте вариативные шаблоны функций. Используйте выражения свертки. Предполагайте, что пакет может содержать аргументы иных типов, которые следует игнорировать. Предполагайте, что пакет содержит хотя бы один аргумент типа \lstinline{double}. Реализуйте отдельные шаблоны функций с полными специализациями для типа \lstinline{double} для обработки всех аргументов типа \lstinline{double} из пакета.

\bigskip

{\large \textbf{04.03} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/04.07.cpp}{\texttt{04.07}}]}}

\bigskip

Реализуйте алгоритм добавления всех аргументов типа \lstinline{int} из пакета в произвольный контейнер, обладающий публичной функцией-членом \lstinline{push_back}. Используйте вариативный шаблон функции. Используйте выражение свертки. Используйте оператор запятая в качестве бинарного оператора в выражении свертки. Предполагайте, что пакет содержит только аргументы типа \lstinline{int}. Используйте стандартный контейнер \lstinline{std::vector} для тестов.

\bigskip

{\large \textbf{04.04} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/04.08.cpp}{\texttt{04.08}}]}}

\bigskip

Доработайте Ваше предыдущее решение задачи 03.07 таким образом, чтобы реализованный вектор мог использоваться для хранения данных любых типов. Используйте шаблон класса. Не~изменяйте~реализацию~вектора.

\bigskip

{\large \textbf{04.05} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/04.17.cpp}{\texttt{04.17}}]}}

\bigskip

Реализуйте алгоритм вычисления N\,-\,ого числа ряда Фибоначчи на основе рекурсивного подхода. Используйте метапрограммирование шаблонов. Реализуйте базовый шаблон структуры \lstinline{Fibonacci} для представления N\,-\,ого числа ряда Фибоначчи. Реализуйте в шаблоне структуры \lstinline{Fibonacci} параметр типа \lstinline{int} для указания номера N на этапе компиляции. Реализуйте в структуре \lstinline{Fibonacci} статическое константное поле типа \lstinline{int} для хранения вычисляемого на этапе компиляции N\,-\,ого числа ряда Фибоначчи. Реализуйте в структуре \lstinline{Fibonacci} статическое утверждение \lstinline{static_assert} для проверки переполнения типа \lstinline{int} при вычислениях на этапе компиляции. Реализуйте две полные специализации шаблона структуры \lstinline{Fibonacci} для представления первого и второго чисел ряда Фибоначчи. Реализуйте шаблон константы для сокращения записей обращений 

к полю шаблона структуры \lstinline{Fibonacci}. Реализуйте тесты на основе статических утверждений \lstinline{static_assert}.

\bigskip

{\large \textbf{04.06} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/04.19.cpp}{\texttt{04.19}}]}}

\bigskip

Доработайте Ваше предыдущее решение задачи 02.05 таким образом, чтобы алгоритм вычисления числа e выполнялся только на этапе компиляции. Реализуйте мгновенную функцию со спецификатором \lstinline{consteval} для вычисления числа e. Используйте стандартный контейнер \lstinline{std::array} со спецификатором \lstinline{constexpr} для хранения различных значений числа epsilon. Реализуйте тесты на основе статических утверждений \lstinline{static_assert}.

\bigskip

{\large \textbf{04.07} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/04.21.cpp}{\texttt{04.21}}]}}

\bigskip

Доработайте пример \href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/04.21.cpp}{\texttt{04.21}} таким образом, чтобы дроби можно было вычитать, умножать и делить на этапе компиляции. Реализуйте шаблоны структур \lstinline{Sub}, \lstinline{Mul} и \lstinline{Div} по аналогии с шаблоном структуры \lstinline{Sum} для представления операций вычитания, умножения и деления дробей соответственно. Используйте в структурах \lstinline{Sub} и \lstinline{Div} структуры \lstinline{Sum} и \lstinline{Mul} соответственно для устранения дублирования кода. Реализуйте в структурах \lstinline{Sum} и \lstinline{Mul} алгоритмы сокращения дробей. Используйте стандартную функцию \lstinline{std::gcd}. Реализуйте в структуре \lstinline{Div} статическое утверждение \lstinline{static_assert} для проверки деления на ноль при вычислениях на этапе компиляции. Реализуйте шаблоны псевдонимов для сокращения записей обращений к псевдонимам типов в шаблонах структур \lstinline{Sub}, \lstinline{Mul} и \lstinline{Div} по аналогии с шаблоном псевдонима \lstinline{sum}. Реализуйте шаблон перегруженного оператора вычитания интервалов со спецификатором \lstinline{constexpr}, используя внутри него шаблон перегру-

женного\,оператора\,сложения\,интервалов.\,Реализуйте\,тесты\,на\,основе\,статических\,утверждений\,\lstinline{static_assert}.

\bigskip

{\large \textbf{04.08} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/04.22.cpp}{\texttt{04.22}}]}}

\bigskip

Доработайте пример \href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/04.22.cpp}{\texttt{04.22}} таким образом, чтобы пользователь мог определить размер кортежа. Реализуйте в классе \lstinline{Tuple} публичную функцию-член \lstinline{size} для получения значения размера кортежа. Используйте оператор \lstinline{sizeof...} для пакета типов кортежа. Реализуйте тесты на основе статических утверждений \lstinline{static_assert}.

\bigskip

{\large \textbf{04.09} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/04.34.cpp}{\texttt{04.34}}]}}

\bigskip

|

\bigskip

{\large \textbf{04.10} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/04.39.cpp}{\texttt{04.39}}]}}

\bigskip

|



\newpage\thispagestyle{empty}\pdfpageheight = 1.00in\enlargethispage{100in}

\section{05. Software Architecture Patterns}



\newpage\thispagestyle{empty}\pdfpageheight = 1.00in\enlargethispage{100in}

\section{06. Projects and Libraries}



\newpage\thispagestyle{empty}\pdfpageheight = 1.00in\enlargethispage{100in}

\section{07. Handling Errors and Debugging}



\newpage\thispagestyle{empty}\pdfpageheight = 10.00in\enlargethispage{100in}

\section{08. Instruments of Calculus}

{\large \textbf{08.01} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/08.05.cpp}{\texttt{08.05}}]}}

\bigskip

Сформулируйте способ хранения полухода шахматной партии с минимально возможными затратами памяти.

\bigskip

{\large \textbf{08.02} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/08.21.cpp}{\texttt{08.21}}]}}

\bigskip

Реализуйте алгоритмы вычисления целой части двоичного логарифма положительных чисел типа \lstinline{int} и типа \lstinline{float}. Предполагайте, что оба этих типа имеют размер 4 байта. Используйте значения типа \lstinline{unsigned int} для выполнения побитовых операций. Используйте оператор \lstinline{static_cast} для явного преобразования числа типа \lstinline{int} к значению типа \lstinline{unsigned int} и объединение \lstinline{union} для явного преобразования числа типа \lstinline{float} к значению типа \lstinline{unsigned int}. Используйте цикл \lstinline{while} и оператор побитового сдвига вправо для поиска старшего ненулевого бита в значении типа \lstinline{unsigned int}. Рассматривайте представление числа типа \lstinline{float} в соответствии со стандартом IEEE 754. Рассматривайте как нормализованные, так и денормализованные числа типа \lstinline{float}. Учитывайте, что экспонента числа типа \lstinline{float} имеет смещение на 127, которое обеспечивает хранение отрицательных степеней без знакового бита. Учитывайте, что максимальное значение экспоненты числа типа \lstinline{float} используется для представления значения бесконечности inf и неопределенного значения\,nan.

\bigskip

{\large \textbf{08.03} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/08.27.cpp}{\texttt{08.27}}]}}

\bigskip

Реализуйте алгоритм эволюции Ричарда Докинза, описанный им в третьей главе книги Слепой часовщик. Сгенерируйте начальную строку из 23 случайных букв. Сгенерируйте 100 копий начальной строки, заменяя каждую букву начальной строки другой случайной буквой с вероятностью 0.05. Вычислите для каждой из 100 сгенерированных строк значение метрики, показывающей посимвольное расхождение сгенерированной строки и целевой строкой methinksitislikeaweasel. Завершите работу алгоритма, если для любой из 100 сгенерированных строк значение метрики оказалось равным 0, в противном случае выберите любую сгенерированную строку с наименьшим значением метрики в качестве новой начальной строки и повторите итерацию алгоритма. Используйте только строчные буквы английского алфавита. Используйте\;стандартный\;символьный\;поток\;вы- 

вода \lstinline{std::cout} для вывода начальных строк на каждой итерации алгоритма, а также конечной целевой строки.





\newpage\thispagestyle{empty}\pdfpageheight = 5.00in\enlargethispage{100in}

\section{09. Detailed Memory Management}

{\large \textbf{09.01} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/09.01.cpp}{\texttt{09.01}}]}}

\bigskip

Реализуйте класс \lstinline{Tracer} для представления трассировщика вызовов функций. Реализуйте в классе \lstinline{Tracer} пользовательский конструктор по умолчанию и пользовательский деструктор, которые будут выводить парные сообщения. Используйте паттерн RAII. Предполагайте, что пользователь самостоятельно создает экземпляр класса \lstinline{Tracer} в начале каждой собственной функции. Используйте стандартный символьный поток вывода \lstinline{std::cout} для вывода сообщений. Используйте стандартную утилиту \lstinline{std::source_location} для вывода дополнительной информации в сообщениях. Реализуйте функциональный макрос \lstinline{trace} по аналогии с функциональным макросом \lstinline{assert}, который позволит отключить всю трассировку при определении макроса \lstinline{NDEBUG}.



\newpage\thispagestyle{empty}\pdfpageheight = 5.00in\enlargethispage{100in}

\section{10. Collections and Containers}

{\large \textbf{10.01} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/10.29.cpp}{\texttt{10.29}}]}}

\bigskip

Реализуйте алгоритм моделирования игры Жизнь по стандартным правилам на игровом поле размером 10 на 10 клеток. Задайте начальное состояние игрового поля случайным образом. Используйте стандартный двумерный контейнер \lstinline{std::vector} для хранения текущего состояния игрового поля.\:Используйте\:стандартный\:сим- 

вольный поток вывода \lstinline{std::cout} для вывода состояния игрового поля на каждой итерации моделирования.

\bigskip

{\large \textbf{10.02} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/10.33.cpp}{\texttt{10.33}}]}}

\bigskip

Реализуйте алгоритм вычисления N\,-\,ого числа ряда Фибоначчи на основе метода матричной экспоненциации. Используйте тип \lstinline{boost::numeric::ublas::matrix} для осуществления вычислений с матрицами. Реализуйте алгоритм быстрого возведения начальной матрицы в степень N. Используйте тип \lstinline{usigned long long int} для значений элементов матриц. Обоснуйте алгоритмическую сложность реализованного алгоритма и сравните ее с алгоритмической сложностью других известных Вам алгоритмов вычисления N\,-\,ого числа ряда Фибоначчи.



\newpage\thispagestyle{empty}\pdfpageheight = 10.00in\enlargethispage{100in}

\section{11. Iterators and Algorithm Libraries}

{\large \textbf{11.01} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/11.01.cpp}{\texttt{11.01}}]}}

\bigskip

Реализуйте функцию, которая возвращает указатель на саму себя так, чтобы можно было написать следующее: \lstinline{Wrapper function = test(); (*function)();} Используйте класс с перегруженным оператором приведения.

\bigskip

{\large \textbf{11.02} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/11.08.cpp}{\texttt{11.08}}]}}

\bigskip

Сравните среднее время вызова лямбда\,-\,функции, сохраненной в переменной с местозаменителем типа \lstinline{auto}, и среднее время вызова той же самой лямбда\,-\,функции, сохраненной в стандартной оболочке \lstinline{std::function}.

\bigskip

{\large \textbf{11.03} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/11.27.cpp}{\texttt{11.27}}]}}

\bigskip

Реализуйте алгоритм решения задачи коммивояжера для полносвязного графа, содержащего 10 вершин. Используйте тип \lstinline{int} для значений весов ребер графа. Инициализируйте веса всех ребер графа случайными значениями от 1 до 10. Используйте стандартный двумерный контейнер \lstinline{std::vector} в качестве симметричной относительно главной диагонали матрицы инцидентности для хранения весов ребер графа. Используйте стандартный алгоритм \lstinline{std::next_permutation} для перебора всех перестановок последовательности обхода вершин, включающей в себя каждую вершину графа только один раз. Учтите, что обход вершин графа должен завершаться в начальной вершине. Используйте стандартный символьный поток вывода \lstinline{std::cout} для вывода матрицы инцидентности, оптимальной последовательности обхода вершин и ее суммарной стоимости.



\newpage\thispagestyle{empty}\pdfpageheight = 5.00in\enlargethispage{100in}

\section{12. Text Data Processing}

{\large \textbf{12.01} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/12.02.cpp}{\texttt{12.02}}]}}

\bigskip

Напишите программу, которая выводит собственный исходный код в стандартный символьный поток вывода \lstinline{std::cout}. Не используйте файловые потоки ввода. Предполагайте, что файл с исходным кодом недоступен.



\newpage\thispagestyle{empty}\pdfpageheight = 1.00in\enlargethispage{100in}

\section{13. Streams and Data Serialization}



\newpage\thispagestyle{empty}\pdfpageheight = 10.00in\enlargethispage{100in}

\section{14. Concurrent Programming}

{\large \textbf{14.01} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/14.09.cpp}{\texttt{14.09}}]}}

\bigskip

Доработайте пример \href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/14.09.cpp}{\texttt{14.09}} таким образом, чтобы алгоритм применял переданное пользователем действие к каждому элементу коллекции вместо сложения элементов коллекции. Сравните тип возвращаемого результата реализованного алгоритма с типом возвращаемого результата стандартного последовательного алгоритма \lstinline{std::for_each} без политики выполнения. Обоснуйте различия процессов выполнения этих двух алгоритмов.

\bigskip

{\large \textbf{14.02} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/14.10.cpp}{\texttt{14.10}}]}}

\bigskip

Реализуйте систему обработки исключений, которые могут быть выброшены функциями, выполняемыми в дополнительных стандартных потоках \lstinline{std::thread}. Используйте обработчик \lstinline{catch} для перехвата всех исключений в функции дополнительного потока. Используйте стандартный указатель \lstinline{std::exception_ptr} для хранения исключения, который будет доступен в функции дополнительного потока и в функции основного потока. Используйте стандартную функцию \lstinline{std::current_exception} для получения указателя на текущее исключение в функции дополнительного потока. Используйте функцию \lstinline{std::rethrow_exception} для повторной генерации, перехвата и обработки сохраненного через указатель исключения в функции основного потока.

\bigskip

{\large \textbf{14.03} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/14.10.cpp}{\texttt{14.10}}]}}

\bigskip





\newpage\thispagestyle{empty}\pdfpageheight = 5.00in\enlargethispage{100in}

\section{15. Network Technologies and Tools}

{\large \textbf{15.01} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/15.01.cpp}{\texttt{15.01}}]}}

\bigskip

Реализуйте алгоритмы шифрования и дешифрования строк, используя шифр Цезаря со сдвигом вправо на заданное количество символов. Предполагайте, что все строки состоят из строчных букв английского алфавита.

\bigskip

{\large \textbf{15.02} \texttt{[\href{https://github.com/i-s-m-mipt/Education/blob/master/projects/examples/source/15.02.cpp}{\texttt{15.02}}]}}

\bigskip

Реализуйте алгоритмы шифрования и дешифрования строк, используя шифр Виженера. Предполагайте, что все строки состоят из строчных букв английского алфавита. Реализуйте алгоритм генерации таблицы Виженера на этапе компиляции. Используйте мгновенную функцию со спецификатором \lstinline{consteval} и двумерный стан- дартный контейнер \lstinline{std::array} со спецификатором \lstinline{constexpr} для генерации и хранения таблицы Виженера.  

\end{document}