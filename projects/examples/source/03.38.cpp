////////////////////////////////////////////////////////////////////////////////////

#include <cassert>
#include <cstddef>
#include <initializer_list>
#include <print>
#include <vector>

////////////////////////////////////////////////////////////////////////////////////

class Vector 
{
public :

    Vector(std::initializer_list < int > list) : m_vector(list) {}

//  --------------------------------------------------------------------------------

    auto const & operator[](std::size_t index) const 
    {
        std::print("Vector::operator[] (1)\n");

        return m_vector[index];
    }
    //!!! только чтение элемента по индексу - константная реализация оператора

//  --------------------------------------------------------------------------------

    auto & operator[](std::size_t index)
    {
        std::print("Vector::operator[] (2)\n");

        return const_cast < int & > (static_cast < Vector const & > (*this)[index]);
    }
    //!!! не константная реализация - подразумевает дальнейшее изменение элемента по индексу
    //  1) делаем *this const ссылкой для вызова первого константного оператора []
    //  2) получаем константную ссылку на данные по индексу
    //  3) вызваем const_cast чтобы убрать константность с полученной ссылки 

private :

    std::vector < int > m_vector;
};

////////////////////////////////////////////////////////////////////////////////////

int main()
{
    auto const x = 1, & y = x;

//  ----------------------------------

    ++(const_cast < int & > (y));
    //!!! убрали константность ссылки и изменили x

//  ----------------------------------

    assert(x == 2);

//  ----------------------------------

    Vector vector = { 1, 2, 3, 4, 5 };

//  ----------------------------------

    assert(vector[0] == 1);
    //!!! вызов не константного оператора, который внутри себя вызывает константный оператор []
}

////////////////////////////////////////////////////////////////////////////////////