//////////////////////////////////////

#ifndef HEADER_06_05

#define HEADER_06_05

//////////////////////////////////////

#pragma once

//////////////////////////////////////

#include <print>

//////////////////////////////////////

void test_v1();

void test_v2();

//////////////////////////////////////

// void test_v3() // error
// { 
//     std::print("test_v3\n");
// }

//////////////////////////////////////

//!!! этот inline нужен именно для возможности множественного пределения которое компилятор объеденит в одно
// тут не будет происходить встраивание в код!!!
// это удобно для реализации маленьких методов класса в его объявлении в hpp
inline void test_v4()
{
    std::print("test_v4\n");
}

//////////////////////////////////////

//!!! все что связано с шаблоном необходимо реализовывать в hpp
// не будет проблем с multiply definition
template < typename T > void test_v5()
{
	std::print("test_v5\n");
}

//////////////////////////////////////

extern int       g_x1;

extern int       g_x2;

extern int const g_x3;

extern int const g_x4;

//////////////////////////////////////
//!!! определение глобальной константы с внутренним связыванием
//тут не будет конфликта при многих include этого hpp но будет излишнее многократное определение-дублирование
       int const g_x5 = 5;
//!!!  тут починили дублирование, а общий результат такой же
//сведение множества определений компоновщиком
inline int const g_x6 = 6;

//////////////////////////////////////

#endif

//////////////////////////////////////