//////////////////////////////////////////////////////////////////////////////////////

#include <print>

//////////////////////////////////////////////////////////////////////////////////////

template < typename T > void test_v1         (T     ) { std::print("test_v1 (1)\n"); }
//!!!полная специализация для базового шаблона выше
//для реализации особого поведения для специализированных типов
//пример если тип это указатель, то мы можем дополнительно добавить разименование в специализацию
template <            > void test_v1 < int > (int   ) { std::print("test_v1 (2)\n"); }
//это именно перегрузка
                        void test_v1         (int   ) { std::print("test_v1 (3)\n"); }

                        void test_v1         (double) { std::print("test_v1 (4)\n"); }

//////////////////////////////////////////////////////////////////////////////////////

template < typename T1, typename T2 > void test_v2(T1, T2)
{
	std::print("test_v2 (1)\n");
}

//////////////////////////////////////////////////////////////////////////////////////

//!!! частичные специализации запрещены для функций
// template < typename T > void test_v2 < T, double > () // error

// {
//     std::print("test_v2 (2)\n");
// }

//////////////////////////////////////////////////////////////////////////////////////

template < typename T > void test_v2(T, double)
{
	std::print("test_v2 (3)\n");
}

//////////////////////////////////////////////////////////////////////////////////////

int main()
{
    test_v1            (1  ); //!!!(13)перегрузка для int, т.к. если есть подходящая не шаблонная версия компилятор выбирает ее!

	test_v1            (1.0);//(15)

	test_v1 <        > (1  ); //!!!(11)

	test_v1 < int    > (1  );//(11)

	test_v1 <        > (1.0);//(7)

	test_v1 < double > (1.0);//(7)

//  -------------------------

	test_v2(1, 2  );

	test_v2(1, 2.0);
}

//////////////////////////////////////////////////////////////////////////////////////

